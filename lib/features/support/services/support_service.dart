import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';

import 'package:securityexperts_app/core/logging/app_logger.dart';
import 'package:securityexperts_app/shared/services/notification_service.dart';
import 'package:securityexperts_app/shared/services/user_profile_service.dart';
import 'package:securityexperts_app/core/service_locator.dart';

import '../data/models/models.dart';
import '../data/repositories/support_repository.dart';
import '../data/repositories/support_attachment_repository.dart';
import 'device_info_service.dart';

// Import extracted modules
import 'support_models.dart';
import 'support_validator.dart';

// Re-export for backward compatibility
export 'support_models.dart';
export 'support_validator.dart';

/// Service for managing support tickets and user feedback.
///
/// Provides a high-level API for:
/// - Creating and submitting support tickets
/// - Viewing ticket history and status
/// - Replying to tickets with attachments
/// - Rating support experience
class SupportService {
  final SupportRepository _repository;
  final SupportAttachmentRepository _attachmentRepository;
  final DeviceInfoService _deviceInfoService;
  // ignore: unused_field - Will be used in phase 4 for ticket notifications
  final NotificationService _notificationService;
  final AppLogger _log;

  static const String _tag = 'SupportService';
  
  // Use constants from SupportConstants for consistency
  static int get maxAttachments => SupportConstants.maxAttachments;
  static int get maxAttachmentSizeMB => SupportConstants.maxAttachmentSizeMB;
  static int get maxSubjectLength => SupportConstants.maxSubjectLength;
  static int get maxDescriptionLength => SupportConstants.maxDescriptionLength;
  static int get maxMessageLength => SupportConstants.maxMessageLength;

  SupportService({
    required SupportRepository repository,
    required SupportAttachmentRepository attachmentRepository,
    required DeviceInfoService deviceInfoService,
    required NotificationService notificationService,
    required AppLogger log,
  }) : _repository = repository,
       _attachmentRepository = attachmentRepository,
       _deviceInfoService = deviceInfoService,
       _notificationService = notificationService,
       _log = log;

  // ========================================
  // TICKET CREATION
  // ========================================

  /// Create a new support ticket.
  ///
  /// Creates a ticket with the provided information and automatically
  /// captures device context for debugging.
  ///
  /// [type] - The type of ticket (bug, feature request, etc.)
  /// [category] - The category for routing (app, account, payment, etc.)
  /// [subject] - Brief summary (max 100 chars)
  /// [description] - Detailed description (max 5000 chars)
  /// [attachments] - Optional file attachments (max 5, 10MB each)
  /// [userEmail] - Optional email override for notifications
  Future<SupportResult<SupportTicket>> createTicket({
    required TicketType type,
    required TicketCategory category,
    required String subject,
    required String description,
    List<PendingAttachment>? attachments,
    String? userEmail,
  }) async {
    _log.info('Creating ticket: type=$type, category=$category', tag: _tag);

    // 1. Validate authentication
    final userId = _getCurrentUserId();
    if (userId == null) {
      _log.warning('Ticket creation failed: not authenticated', tag: _tag);
      return SupportResult.failure(SupportError.notAuthenticated);
    }

    // 2. Validate input
    final validationError = _validateTicketInput(
      subject,
      description,
      attachments,
    );
    if (validationError != null) {
      _log.warning(
        'Ticket validation failed: ${validationError.message}',
        tag: _tag,
      );
      return SupportResult.failure(validationError);
    }

    // 3. Validate attachment sizes
    if (attachments != null) {
      for (final attachment in attachments) {
        final sizeBytes = attachment.bytes?.length ?? 0;
        final sizeMB = sizeBytes / (1024 * 1024);
        if (sizeMB > maxAttachmentSizeMB) {
          _log.warning('Attachment too large: ${attachment.filename}', tag: _tag);
          return SupportResult.failure(SupportError.attachmentTooLarge);
        }
      }
    }

    try {
      // 4. Capture device context
      final deviceContext = await _deviceInfoService.captureDeviceContext();

      // 5. Create ticket first to get ID
      final now = DateTime.now();
      final ticket = SupportTicket(
        id: '', // Will be set by Firestore
        ticketNumber: '', // Generated by Cloud Function
        userId: userId,
        userEmail: userEmail ?? _getCurrentUserEmail() ?? '',
        userName: _getCurrentUserName() ?? 'User',
        type: type,
        category: category,
        subject: subject.trim(),
        description: description.trim(),
        attachments: [],
        deviceContext: deviceContext,
        status: TicketStatus.open,
        priority: _getPriorityFromType(type),
        createdAt: now,
        updatedAt: now,
        lastActivityAt: now,
        messageCount: 0,
        hasUnreadSupportMessages: false,
      );

      final createdTicket = await _repository.createTicket(ticket);
      if (createdTicket == null) {
        _log.error('Failed to create ticket - null response', tag: _tag);
        return SupportResult.failure(SupportError.unknown);
      }

      // 6. Upload attachments if any
      List<TicketAttachment> uploadedAttachments = [];
      if (attachments != null && attachments.isNotEmpty) {
        try {
          final uploaded = await _attachmentRepository.uploadPendingAttachments(
            ticketId: createdTicket.id,
            attachments: attachments,
          );
          uploadedAttachments = uploaded ?? [];

          if (uploadedAttachments.isNotEmpty) {
            // Update ticket with attachments
            await _repository.updateTicket(createdTicket.id, {
              'attachments': uploadedAttachments
                  .map((a) => a.toJson())
                  .toList(),
            });
          }
        } catch (e) {
          _log.warning('Failed to upload attachments: $e', tag: _tag);
          // Continue without attachments - ticket is still created
        }
      }

      final finalTicket = createdTicket.copyWith(
        attachments: uploadedAttachments,
      );

      _log.info('Ticket created successfully: ${finalTicket.id}', tag: _tag);
      return SupportResult.success(finalTicket);
    } catch (e, stack) {
      _log.error(
        'Failed to create ticket',
        error: e,
        stackTrace: stack,
        tag: _tag,
      );
      return SupportResult.failure(SupportError.unknown);
    }
  }

  /// Validate ticket input using SupportValidator.
  SupportError? _validateTicketInput(
    String subject,
    String description,
    List<PendingAttachment>? attachments,
  ) {
    return SupportValidator.validateTicketInput(subject, description, attachments);
  }

  /// Get priority based on ticket type using SupportValidator.
  TicketPriority _getPriorityFromType(TicketType type) {
    return SupportValidator.getPriorityFromType(type);
  }

  // ========================================
  // TICKET RETRIEVAL
  // ========================================

  /// Get all tickets for the current user.
  ///
  /// Supports filtering by status and type, with pagination.
  Future<SupportResult<List<SupportTicket>>> getUserTickets({
    TicketStatus? statusFilter,
    TicketType? typeFilter,
    int limit = 20,
    DocumentSnapshot? startAfter,
  }) async {
    final userId = _getCurrentUserId();
    if (userId == null) {
      return SupportResult.failure(SupportError.notAuthenticated);
    }

    try {
      final tickets = await _repository.getTicketsByUser(
        userId: userId,
        statusFilter: statusFilter,
        limit: limit,
        startAfter: startAfter,
      );

      // Apply type filter client-side if provided
      final filteredTickets = typeFilter != null
          ? tickets.where((t) => t.type == typeFilter).toList()
          : tickets;

      return SupportResult.success(filteredTickets);
    } catch (e, stack) {
      _log.error(
        'Failed to get user tickets',
        error: e,
        stackTrace: stack,
        tag: _tag,
      );
      return SupportResult.failure(SupportError.networkError);
    }
  }

  /// Get open tickets for current user.
  Future<SupportResult<List<SupportTicket>>> getOpenTickets() async {
    final userId = _getCurrentUserId();
    if (userId == null) {
      return SupportResult.failure(SupportError.notAuthenticated);
    }

    try {
      final tickets = await _repository.getOpenTickets(userId);
      return SupportResult.success(tickets);
    } catch (e, stack) {
      _log.error(
        'Failed to get open tickets',
        error: e,
        stackTrace: stack,
        tag: _tag,
      );
      return SupportResult.failure(SupportError.networkError);
    }
  }

  /// Get a specific ticket by ID.
  ///
  /// Verifies ownership before returning.
  Future<SupportResult<SupportTicket>> getTicketById(String ticketId) async {
    try {
      final ticket = await _repository.getTicket(ticketId);
      if (ticket == null) {
        return SupportResult.failure(SupportError.ticketNotFound);
      }

      // Verify ownership
      final userId = _getCurrentUserId();
      if (ticket.userId != userId) {
        _log.warning('Access denied to ticket: $ticketId', tag: _tag);
        return SupportResult.failure(SupportError.accessDenied);
      }

      return SupportResult.success(ticket);
    } catch (e, stack) {
      _log.error(
        'Failed to get ticket',
        error: e,
        stackTrace: stack,
        tag: _tag,
      );
      return SupportResult.failure(SupportError.networkError);
    }
  }

  /// Watch a ticket for real-time updates.
  Stream<SupportTicket?> watchTicket(String ticketId) {
    return _repository.watchTicket(ticketId);
  }

  /// Watch all tickets for current user.
  Stream<List<SupportTicket>> watchUserTickets({TicketStatus? statusFilter}) {
    final userId = _getCurrentUserId();
    if (userId == null) {
      return Stream.value([]);
    }
    return _repository.watchUserTickets(userId, statusFilter: statusFilter);
  }

  /// Get count of tickets with unread support messages.
  Future<int> getUnreadTicketCount() async {
    final userId = _getCurrentUserId();
    if (userId == null) return 0;

    try {
      return await _repository.getUnreadTicketCount(userId);
    } catch (e) {
      _log.warning('Failed to get unread count: $e', tag: _tag);
      return 0;
    }
  }

  // ========================================
  // TICKET MESSAGING
  // ========================================

  /// Get messages for a ticket.
  Future<List<SupportMessage>> getTicketMessages(String ticketId) async {
    try {
      return await _repository.getMessages(ticketId);
    } catch (e, stack) {
      _log.error(
        'Failed to get messages',
        error: e,
        stackTrace: stack,
        tag: _tag,
      );
      return [];
    }
  }

  /// Watch messages for a ticket in real-time.
  Stream<List<SupportMessage>> watchTicketMessages(String ticketId) {
    return _repository.watchMessages(ticketId);
  }

  /// Reply to a ticket.
  ///
  /// Adds a new message from the user to the ticket.
  Future<SupportResult<SupportMessage>> replyToTicket({
    required String ticketId,
    required String content,
    List<PendingAttachment>? attachments,
  }) async {
    _log.info('Replying to ticket: $ticketId', tag: _tag);

    // 1. Validate authentication
    final userId = _getCurrentUserId();
    if (userId == null) {
      return SupportResult.failure(SupportError.notAuthenticated);
    }

    // 2. Validate ticket ownership and status
    final ticketResult = await getTicketById(ticketId);
    if (ticketResult.isFailure) {
      return SupportResult.failure(ticketResult.error!);
    }

    final ticket = ticketResult.value!;
    if (!ticket.canReply) {
      return SupportResult.failure(SupportError.ticketClosed);
    }

    // 3. Validate message
    if (content.trim().isEmpty && (attachments == null || attachments.isEmpty)) {
      return SupportResult.failure(SupportError.invalidMessage);
    }
    if (content.length > maxMessageLength) {
      return SupportResult.failure(SupportError.descriptionTooLong);
    }

    // 4. Validate attachments
    if (attachments != null && attachments.length > maxAttachments) {
      return SupportResult.failure(SupportError.tooManyAttachments);
    }

    try {
      // 5. Upload attachments if any
      List<TicketAttachment> uploadedAttachments = [];
      if (attachments != null && attachments.isNotEmpty) {
        try {
          final uploaded = await _attachmentRepository.uploadPendingAttachments(
            ticketId: ticketId,
            attachments: attachments,
            subPath: 'messages',
          );
          uploadedAttachments = uploaded ?? [];
        } catch (e) {
          _log.warning('Failed to upload message attachments: $e', tag: _tag);
          // Continue without attachments
        }
      }

      // 6. Create message
      final message = SupportMessage(
        id: '',
        ticketId: ticketId,
        senderId: userId,
        senderType: MessageSenderType.user,
        senderName: _getCurrentUserName() ?? 'User',
        content: content.trim(),
        attachments: uploadedAttachments,
        createdAt: DateTime.now(),
      );

      final createdMessage = await _repository.addMessage(ticketId, message);
      if (createdMessage == null) {
        _log.error('Failed to create message - null response', tag: _tag);
        return SupportResult.failure(SupportError.unknown);
      }
      _log.info('Reply sent successfully', tag: _tag);
      return SupportResult.success(createdMessage);
    } catch (e, stack) {
      _log.error(
        'Failed to send reply',
        error: e,
        stackTrace: stack,
        tag: _tag,
      );
      return SupportResult.failure(SupportError.unknown);
    }
  }

  /// Mark support messages as read.
  Future<void> markMessagesAsRead(String ticketId) async {
    try {
      _log.info('Service: Marking messages as read for ticket $ticketId', tag: _tag);
      await _repository.markMessagesAsRead(ticketId);
      _log.info('Service: Successfully marked messages as read', tag: _tag);
    } catch (e) {
      _log.error('Service: Failed to mark messages as read: $e', tag: _tag);
      rethrow; // Re-throw so caller can handle
    }
  }

  // ========================================
  // TICKET FEEDBACK
  // ========================================

  /// Rate support experience after resolution.
  ///
  /// [ticketId] - The ticket to rate
  /// [rating] - Rating from 1-5
  /// [comment] - Optional feedback comment
  Future<SupportResult<void>> rateSupportExperience({
    required String ticketId,
    required int rating,
    String? comment,
  }) async {
    _log.info('Rating ticket: $ticketId with $rating stars', tag: _tag);

    // Validate rating
    if (rating < 1 || rating > 5) {
      return SupportResult.failure(SupportError.invalidRating);
    }

    // Get ticket and verify
    final ticketResult = await getTicketById(ticketId);
    if (ticketResult.isFailure) {
      return SupportResult.failure(ticketResult.error!);
    }

    final ticket = ticketResult.value!;

    // Only allow rating resolved/closed tickets
    if (ticket.status != TicketStatus.resolved &&
        ticket.status != TicketStatus.closed) {
      return SupportResult.failure(SupportError.cannotRateUnresolvedTicket);
    }

    // Already rated?
    if (ticket.userSatisfactionRating != null) {
      _log.info('Ticket already rated, updating rating', tag: _tag);
    }

    try {
      await _repository.updateTicketSatisfaction(
        ticketId,
        rating: rating,
        feedback: comment?.trim(),
      );
      _log.info('Ticket rated successfully', tag: _tag);
      return SupportResult.success(null);
    } catch (e, stack) {
      _log.error(
        'Failed to rate ticket',
        error: e,
        stackTrace: stack,
        tag: _tag,
      );
      return SupportResult.failure(SupportError.unknown);
    }
  }

  // ========================================
  // HELPER METHODS
  // ========================================

  String? _getCurrentUserId() {
    return sl<FirebaseAuth>().currentUser?.uid;
  }

  String? _getCurrentUserEmail() {
    return sl<FirebaseAuth>().currentUser?.email;
  }

  String? _getCurrentUserName() {
    // First try to get the display name from user profile service
    final profileService = UserProfileService();
    final displayName = profileService.userProfile?.name;
    if (displayName != null && displayName.isNotEmpty) {
      return displayName;
    }
    
    // Fallback to Firebase Auth displayName if profile not loaded
    return sl<FirebaseAuth>().currentUser?.displayName;
  }
}
