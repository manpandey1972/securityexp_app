import 'dart:convert';
import 'dart:typed_data';

import 'package:equatable/equatable.dart';

/// Represents a signed pre-key used in the X3DH key exchange.
///
/// Signed pre-keys are rotated weekly. The signature proves the SPK
/// was generated by the owner of the identity key.
class SignedPreKey extends Equatable {
  /// Unique identifier for this signed pre-key.
  final int keyId;

  /// X25519 public key (32 bytes).
  final Uint8List publicKey;

  /// X25519 private key (32 bytes). Only stored locally.
  final Uint8List? privateKey;

  /// Ed25519 signature over publicKey (64 bytes).
  final Uint8List signature;

  /// Timestamp when this SPK was generated.
  final DateTime createdAt;

  const SignedPreKey({
    required this.keyId,
    required this.publicKey,
    this.privateKey,
    required this.signature,
    required this.createdAt,
  });

  factory SignedPreKey.fromJson(Map<String, dynamic> json) {
    return SignedPreKey(
      keyId: json['key_id'] as int,
      publicKey: base64Decode(json['public_key'] as String),
      signature: base64Decode(json['signature'] as String),
      createdAt: json['created_at'] != null
          ? DateTime.parse(json['created_at'] as String)
          : DateTime.now(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'key_id': keyId,
      'public_key': base64Encode(publicKey),
      'signature': base64Encode(signature),
      'created_at': createdAt.toIso8601String(),
    };
  }

  @override
  List<Object?> get props => [keyId, publicKey, signature, createdAt];
}

/// Represents a one-time pre-key for enhanced forward secrecy.
///
/// Each OPK is used exactly once in an X3DH exchange and then deleted.
class OneTimePreKey extends Equatable {
  /// Unique identifier for this one-time pre-key.
  final int keyId;

  /// X25519 public key (32 bytes).
  final Uint8List publicKey;

  /// X25519 private key (32 bytes). Only stored locally.
  final Uint8List? privateKey;

  const OneTimePreKey({
    required this.keyId,
    required this.publicKey,
    this.privateKey,
  });

  factory OneTimePreKey.fromJson(Map<String, dynamic> json) {
    return OneTimePreKey(
      keyId: json['key_id'] as int,
      publicKey: base64Decode(json['public_key'] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'key_id': keyId,
      'public_key': base64Encode(publicKey),
    };
  }

  @override
  List<Object?> get props => [keyId, publicKey];
}

/// A published bundle of public keys for asynchronous X3DH key exchange.
///
/// Other users fetch this bundle to initiate an encrypted session
/// without requiring the target user to be online.
class PreKeyBundle extends Equatable {
  /// The device owner's user ID.
  final String userId;

  /// The device ID this bundle belongs to.
  final String deviceId;

  /// X25519 identity public key (32 bytes).
  final Uint8List identityKey;

  /// Ed25519 signing public key (32 bytes).
  final Uint8List signingKey;

  /// The current signed pre-key.
  final SignedPreKey signedPreKey;

  /// Available one-time pre-keys.
  final List<OneTimePreKey> oneTimePreKeys;

  /// Registration ID (uint32).
  final int registrationId;

  /// Human-readable device name.
  final String deviceName;

  /// KMS attestation signature.
  final String? attestation;

  const PreKeyBundle({
    required this.userId,
    required this.deviceId,
    required this.identityKey,
    required this.signingKey,
    required this.signedPreKey,
    required this.oneTimePreKeys,
    required this.registrationId,
    required this.deviceName,
    this.attestation,
  });

  factory PreKeyBundle.fromJson(Map<String, dynamic> json) {
    return PreKeyBundle(
      userId: json['user_id'] as String? ?? '',
      deviceId: json['device_id'] as String? ?? '',
      identityKey: base64Decode(json['identity_key'] as String),
      signingKey: base64Decode(json['signing_key'] as String),
      signedPreKey: SignedPreKey.fromJson(
        json['signed_pre_key'] as Map<String, dynamic>,
      ),
      oneTimePreKeys: (json['one_time_pre_keys'] as List<dynamic>?)
              ?.map((e) => OneTimePreKey.fromJson(e as Map<String, dynamic>))
              .toList() ??
          [],
      registrationId: json['registration_id'] as int? ?? 0,
      deviceName: json['device_name'] as String? ?? '',
      attestation: json['attestation'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'user_id': userId,
      'device_id': deviceId,
      'identity_key': base64Encode(identityKey),
      'signing_key': base64Encode(signingKey),
      'signed_pre_key': signedPreKey.toJson(),
      'one_time_pre_keys': oneTimePreKeys.map((k) => k.toJson()).toList(),
      'registration_id': registrationId,
      'device_name': deviceName,
      if (attestation != null) 'attestation': attestation,
    };
  }

  PreKeyBundle copyWith({
    String? userId,
    String? deviceId,
    Uint8List? identityKey,
    Uint8List? signingKey,
    SignedPreKey? signedPreKey,
    List<OneTimePreKey>? oneTimePreKeys,
    int? registrationId,
    String? deviceName,
    String? attestation,
  }) {
    return PreKeyBundle(
      userId: userId ?? this.userId,
      deviceId: deviceId ?? this.deviceId,
      identityKey: identityKey ?? this.identityKey,
      signingKey: signingKey ?? this.signingKey,
      signedPreKey: signedPreKey ?? this.signedPreKey,
      oneTimePreKeys: oneTimePreKeys ?? this.oneTimePreKeys,
      registrationId: registrationId ?? this.registrationId,
      deviceName: deviceName ?? this.deviceName,
      attestation: attestation ?? this.attestation,
    );
  }

  @override
  List<Object?> get props => [
        userId,
        deviceId,
        identityKey,
        signingKey,
        signedPreKey,
        oneTimePreKeys,
        registrationId,
        deviceName,
        attestation,
      ];
}
